/**
 * ğŸ“‹ íŒŒì¼ ëª©ì°¨ (app/api/auth/signup/route.ts)
 * ========================================
 * ğŸ¯ ì£¼ìš” ì—­í• : ì‚¬ìš©ì íšŒì›ê°€ì… API ì—”ë“œí¬ì¸íŠ¸
 * 
 * ğŸ“¦ êµ¬ì„± ìš”ì†Œ:
 * - ë¼ì¸ 1-20: í•„ìˆ˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë° ëª¨ë¸ ì„í¬íŠ¸
 * - ë¼ì¸ 22-35: íšŒì›ê°€ì… ìš”ì²­ ë°ì´í„° íƒ€ì… ì •ì˜
 * - ë¼ì¸ 37-60: ì…ë ¥ ë°ì´í„° ê²€ì¦ í•¨ìˆ˜
 * - ë¼ì¸ 62-120: POST í•¸ë“¤ëŸ¬ (íšŒì›ê°€ì… ì²˜ë¦¬)
 * - ë¼ì¸ 122-140: ì—ëŸ¬ ì‘ë‹µ í—¬í¼ í•¨ìˆ˜
 * 
 * ğŸ”§ ì£¼ìš” ê¸°ëŠ¥:
 * - ì‚¬ìš©ì íšŒì›ê°€ì… ì²˜ë¦¬
 * - ì…ë ¥ ë°ì´í„° ê²€ì¦ (ì´ë©”ì¼, ì‚¬ìš©ìëª…, ë¹„ë°€ë²ˆí˜¸)
 * - ì¤‘ë³µ ê³„ì • í™•ì¸
 * - ë¹„ë°€ë²ˆí˜¸ í•´ì‹± (User ëª¨ë¸ì—ì„œ ìë™ ì²˜ë¦¬)
 * - JWT í† í° ìƒì„± ë° ë°˜í™˜
 * 
 * ğŸ”’ ë³´ì•ˆ ê¸°ëŠ¥:
 * - ì…ë ¥ ë°ì´í„° ê²€ì¦
 * - ì¤‘ë³µ ê³„ì • ë°©ì§€
 * - ë¹„ë°€ë²ˆí˜¸ ìë™ í•´ì‹±
 * - ì—ëŸ¬ ì •ë³´ ìµœì†Œí™”
 */

import { NextRequest, NextResponse } from 'next/server';
import { connectDB } from '@/lib/mongoose';
import User from '@/lib/models/User';
import jwt from 'jsonwebtoken';
import { z } from 'zod';

/**
 * íšŒì›ê°€ì… ìš”ì²­ ë°ì´í„° ê²€ì¦ ìŠ¤í‚¤ë§ˆ
 */
const signupSchema = z.object({
  username: z.string()
    .min(3, 'ì‚¬ìš©ìëª…ì€ ìµœì†Œ 3ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤')
    .max(20, 'ì‚¬ìš©ìëª…ì€ ìµœëŒ€ 20ìê¹Œì§€ ê°€ëŠ¥í•©ë‹ˆë‹¤')
    .regex(/^[a-zA-Z0-9_]+$/, 'ì‚¬ìš©ìëª…ì€ ì˜ë¬¸, ìˆ«ì, ì–¸ë”ìŠ¤ì½”ì–´ë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤'),
  name: z.string()
    .min(2, 'ì´ë¦„ì€ ìµœì†Œ 2ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤')
    .max(50, 'ì´ë¦„ì€ ìµœëŒ€ 50ìê¹Œì§€ ê°€ëŠ¥í•©ë‹ˆë‹¤'),
  email: z.string()
    .email('ì˜¬ë°”ë¥¸ ì´ë©”ì¼ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤')
    .toLowerCase(),
  password: z.string()
    .min(8, 'ë¹„ë°€ë²ˆí˜¸ëŠ” ìµœì†Œ 8ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤')
    .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, 'ë¹„ë°€ë²ˆí˜¸ëŠ” ëŒ€ë¬¸ì, ì†Œë¬¸ì, ìˆ«ìë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤'),
  password2: z.string()
}).refine((data) => data.password === data.password2, {
  message: 'ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤',
  path: ['password2']
});

type SignupRequest = z.infer<typeof signupSchema>;

/**
 * JWT í† í° ìƒì„± í•¨ìˆ˜
 */
function generateTokens(userId: string) {
  const accessToken = jwt.sign(
    { userId },
    process.env.JWT_SECRET || 'fallback-secret',
    { expiresIn: '1h' }
  );
  
  const refreshToken = jwt.sign(
    { userId },
    process.env.JWT_REFRESH_SECRET || 'fallback-refresh-secret',
    { expiresIn: '7d' }
  );
  
  return { accessToken, refreshToken };
}

/**
 * POST /api/auth/signup
 * ì‚¬ìš©ì íšŒì›ê°€ì… ì²˜ë¦¬
 */
export async function POST(request: NextRequest) {
  try {
    // MongoDB ì—°ê²°
    await connectDB();
    
    // ìš”ì²­ ë°ì´í„° íŒŒì‹±
    const body = await request.json();
    console.log('ğŸ” íšŒì›ê°€ì… ìš”ì²­ ë°ì´í„°:', { 
      username: body.username, 
      email: body.email,
      name: body.name 
    });
    
    // ì…ë ¥ ë°ì´í„° ê²€ì¦
    const validationResult = signupSchema.safeParse(body);
    if (!validationResult.success) {
      console.log('âŒ ì…ë ¥ ë°ì´í„° ê²€ì¦ ì‹¤íŒ¨:', validationResult.error.errors);
      return NextResponse.json(
        { 
          error: 'ì…ë ¥ ë°ì´í„°ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤',
          details: validationResult.error.errors
        },
        { status: 400 }
      );
    }
    
    const { username, name, email, password } = validationResult.data;
    
    // ì¤‘ë³µ ê³„ì • í™•ì¸
    const existingUser = await User.findOne({
      $or: [
        { email },
        { username }
      ]
    });
    
    if (existingUser) {
      const duplicateField = existingUser.email === email ? 'email' : 'username';
      console.log(`âŒ ì¤‘ë³µ ê³„ì • ë°œê²¬: ${duplicateField} = ${duplicateField === 'email' ? email : username}`);
      
      return NextResponse.json(
        { 
          error: duplicateField === 'email' 
            ? 'ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ì´ë©”ì¼ì…ë‹ˆë‹¤' 
            : 'ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ì‚¬ìš©ìëª…ì…ë‹ˆë‹¤',
          field: duplicateField
        },
        { status: 409 }
      );
    }
    
    // ìƒˆ ì‚¬ìš©ì ìƒì„±
    const newUser = new User({
      username,
      name,
      email,
      password, // User ëª¨ë¸ì—ì„œ ìë™ìœ¼ë¡œ í•´ì‹±ë¨
      isEmailVerified: false // ì´ë©”ì¼ ì¸ì¦ì€ ë³„ë„ í”„ë¡œì„¸ìŠ¤
    });
    
    const savedUser = await newUser.save();
    console.log('âœ… ìƒˆ ì‚¬ìš©ì ìƒì„± ì™„ë£Œ:', { 
      id: savedUser._id, 
      username: savedUser.username,
      email: savedUser.email 
    });
    
    // JWT í† í° ìƒì„±
    const { accessToken, refreshToken } = generateTokens(savedUser._id.toString());
    
    // ì‘ë‹µ ë°ì´í„° (ë¹„ë°€ë²ˆí˜¸ ì œì™¸)
    const userResponse = {
      id: savedUser._id,
      username: savedUser.username,
      name: savedUser.name,
      email: savedUser.email,
      isEmailVerified: savedUser.isEmailVerified,
      role: savedUser.role,
      createdAt: savedUser.createdAt
    };
    
    console.log('ğŸ‰ íšŒì›ê°€ì… ì„±ê³µ:', { userId: savedUser._id });
    
    return NextResponse.json(
      {
        message: 'íšŒì›ê°€ì…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤',
        user: userResponse,
        accessToken,
        refreshToken
      },
      { status: 201 }
    );
    
  } catch (error) {
    console.error('ğŸ’¥ íšŒì›ê°€ì… ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:', error);
    
    // MongoDB ì¤‘ë³µ í‚¤ ì—ëŸ¬ ì²˜ë¦¬
    if (error instanceof Error && 'code' in error && error.code === 11000) {
      return NextResponse.json(
        { error: 'ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ì´ë©”ì¼ ë˜ëŠ” ì‚¬ìš©ìëª…ì…ë‹ˆë‹¤' },
        { status: 409 }
      );
    }
    
    return NextResponse.json(
      { error: 'íšŒì›ê°€ì… ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤' },
      { status: 500 }
    );
  }
} 